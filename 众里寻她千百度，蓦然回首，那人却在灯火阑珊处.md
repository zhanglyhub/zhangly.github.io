# 众里寻她千百度，蓦然回首，那人却在灯火阑珊处。

# ***BFS***

一般都为多源$bfs$，队列实现，每次处理一层(我更喜欢叫它如下弹出行为重复$size$遍)

LeetCode-1162地图分析

https://leetcode.cn/problems/as-far-from-land-as-possible/description/

几乎可以说是模板题，要求最远的距离，其实就是在求$bfs$了多少层返回层数即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxDistance(vector<vector<int>>& grid) {
        int n = grid.size();
        int d[] = {-1, 0, 1, 0, -1};//d数组的用法
        int sea = 0;
         queue<pair<int, int>> q;
        bool vis[101][101] = {};
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 1) {
                    q.push({i, j});
                    vis[i][j] = 1;
                } else {
                    vis[i][j] = 0;
                    sea++;
                }
            }
        }
        if(sea == 0 || sea == n * n) return -1;
        int level = -1;        //注意level初始化为-1，默认从第0层开始
        while(!q.empty()) {
            level++;
            //cout << level << ' ';
            int sz = q.size();
            for(int i = 0; i < sz; i++) {
                int x = q.front().first;
                int y = q.front().second;
                q.pop();
                for(int i = 0; i < 4; i++) {
                    int nx = x + d[i];
                    int ny = y + d[i + 1];
                    if(nx < n && nx >= 0 && ny >= 0 && ny < n && !vis[nx][ny] && grid[nx][ny] == 0) {
                        vis[nx][ny] = 1;
                        //cout << nx << ' ' << ny << endl;
                        q.push({nx, ny});
                    }
                }
            }
        }
        return level;
    }
};
```



LeetCode-691贴纸拼词

https://leetcode.cn/problems/stickers-to-spell-word/description/

这道题有多种解法，动态规划也能解（好吧其实是我没学），$bfs$ 的解法挺妙的，我们可以这样考虑，每次使用这些贴纸可以搞定$target$多少字符，自然智慧，显然字符的顺序是不影响答案的，所以我们可以先排序，注意这里的剪枝，考虑我们迟早要干掉首字符的，莫不如顶着首字符先干掉，再去干掉后面的字符，接下来就是$bfs\:+del$函数的设计，具体看$code$

# ***ACcode***

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        int n = stickers.size();
        sort(target.begin(), target.end());
        vector<string> g[401];
        for(auto str : stickers) {
            sort(str.begin(), str.end());
            for(int i = 0; i < str.size(); i++) {
                if(i == 0 || str[i] != str[i - 1]) {
                    g[str[i] - 'a'].push_back(str);//避免重复加入
                }
            }
        }
        unordered_map<string, bool> vis;
        queue<string> q;
        vis[target] = 1;
        q.push(target);
        int level = 1;
        while(!q.empty()) {
            int sz= q.size();
            for(int i = 0; i < sz; i++) {
                string cur = q.front();
                q.pop();
                for(string s : g[cur[0] - 'a']) {
                    string nxt = del(cur, s);
                    sort(nxt.begin(), nxt.end());
                    //cout << nxt << ' ';
                    if(nxt == "") return level;
                    else if(!vis[nxt]) {
                        vis[nxt] = 1;
                        q.push(nxt);
                    }
                }
            }
            level++;
        }
        return -1;
    }
    string del(string cur, string s) {
        vector<int> cnt1 (26, 0);//词频统计
        vector<int> cnt2 (26, 0);
        string ans = "";
        for(int i = 0; i < cur.size(); i++) {
            cnt1[cur[i] - 'a']++;
        }
        for(int i = 0; i < s.size(); i++) {
            cnt2[s[i] - 'a']++;
        }
        for(int i = 0; i < 26; i++ ) {
            int times = cnt1[i] - cnt2[i];
            if(times > 0) {
                ans += string(times, i + 'a');
            }
        }
        return ans;
    }
};
```



# bfs变种之01bfs

顾名思义，就是图中所有边的权值只有01两种，01bfs我们使用双端队列，将权值为1的从尾部加入，权值为0的从头部加入。

LeetCode-2290

https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/

板题

```cpp
#include<bits/stdc++.h>
#define inf 1 << 30
using namespace std;

class Solution {
public:
    int minCost(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<int> dis(n * m, inf);
        dis[0] = 0;
        int dx[] = {0, -1, 0, 1, 0};
        int dy[] = {0, 0, 1, 0, -1};
        deque<pair<int, int>> dq;
        dq.push_front({0, 0});
        while(!dq.empty()) {
            int x = dq.front().first;
            int y = dq.front().second;
            int idx = x * m + y;
            for(int i = 1; i <= 4; i++) {
                int nx = x + d[i];
                int ny = y + d[i];
                int nidx = x * m + y;
                if(nx < n && ny < m && nx >= 0 && ny >= 0)  {
                    int w = grid[nx][ny] == i;
                    if(dis[nidx] > dis[idx] + w) {
                        dis[nidx] = dis[idx] + w;
                        if(w == 0) dq.push_front({nx, ny};)
                        else dq.push_back({nx, ny});
                    }
                }
            }
        }
        return dis[n * m - 1];
    }
};
```

这里有个技巧建立二维到一维的映射公式：$x * m + y$



LeetCode-1368

https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/

其实也是简单01bfs啦，要看明白这个转化，箭头和我要去的方向一样就是0，否则就是1

******

***ACcode***

```cpp
#include<bits/stdc++.h>
#define inf 1 << 30
using namespace std;

class Solution {
public:
    int minCost(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<int> dis(n * m, inf);
        dis[0] = 0;
        int dx[] = {0, 0, 0, 1, -1};
        int dy[] = {0, 1, -1, 0, 0};
        deque<pair<int, int>> dq;
        //dq.clear();
        dq.push_front({0, 0});
        while(!dq.empty()) {
            int x = dq.front().first;
            int y = dq.front().second;
            dq.pop_front();
            int idx = x * m + y;
            if (idx == n * m - 1) return dis[idx];//安全返回
            for(int i = 1; i <= 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];;
                int nidx = nx * m + ny;
                if(nx < n && ny < m && nx >= 0 && ny >= 0)  {
                    int w = (grid[x][y] == i) ? 0 : 1;
                    if(dis[nidx] > dis[idx] + w) {
                        dis[nidx] = dis[idx] + w;//这里要注意提前返回的时机不能在这里，因为只有当前节点"真正"从队列中弹出时才能返回（更新）
                        if(w == 0) dq.push_front({nx, ny});
                        else dq.push_back({nx, ny});
                    }
                }
            }
        }
        // for(int i = 0; i < dis.size(); i++) {
        //     cout << dis[i] << ' ';
        // }
        return dis[n * m - 1];
    }
};
```
