## 最小生成树

### **P1194**

悼念.........我调了三个小时， 题目数据B给的有问题，导致我在这WA了三次，唉。

题目要求求最小花费的钱数，其实想到做法也挺简单的..........................................吧。

买东西的花费无非就两种l，我们可以构造一个虚点0，把0和每个物品自身连边权值是a，每个物品直接连边，权值为x，跑最小生成树即可。具体见注释

# ***ACcode***

```cpp
#include<bits/stdc++.h>
#define inf 1 << 30
using namespace std;

const int N = 5005;        //数组开大一些！！！切记！！！！！
int a, b, x, pa[N];
struct e {
    int u, v, w;
    bool operator< (const e& x) const {
        return w < x.w;
    }
};
vector<e> g;
int find(int x) {return x == pa[x] ? x : pa[x] = find(pa[x]);}
void union_(int x, int y) {
    x = find(x), y = find(y);
    if(x != y) {
        pa[x] = y;
    }
}
int main() {
    cin >> a >> b;
    for(int i = 1; i <= a; i++) pa[i] = i;
    for(int i = 1; i <= b; i++) {
       g.push_back({0, i, a});              //虚点连边
    }
    for(int i = 1; i <= b; i++) {j
        for(int j = 1; j <= b; j++) {
            cin >> x;
            if(i < j && x != 0)            //i == j,x == 0 不输入，不优惠
            g.push_back({i, j, x});       //节点连边
        }
    }
    sort(g.begin(), g.end());
    int ans = 0, cnt = 0;                //最小生成树
    for(auto &xx : g) {
        int u = xx.u, v = xx.v, w = xx.w;
        if(find(u) != find(v)) {
            union_(u, v);
            ans += w;
            cnt++;
        }
        if(cnt == b) break;
    }
    if(cnt < b) ans += (b - cnt) * a;       //不够的点要补回来，在这WA了   
    cout << ans << endl;
    return 0;
}
```



# ***双倍快乐***

[P1550 [USACO08OCT] Watering Hole G - 洛谷](https://www.luogu.com.cn/problem/P1550)



一发过了

# ***ACcode***

```cpp
#include<bits/stdc++.h>
#define inf 1 << 30
using namespace std;

const int N = 305;
int n, w, p, pa[N];
struct e {
    int u, v, w;
    bool operator< (const e& x) const {
        return w < x.w;
    }
};
vector<e> g;
int find(int x) {return x == pa[x] ? x : pa[x] = find(pa[x]);}
void union_(int x, int y) {
    x = find(x), y = find(y);
    if(x != y) pa[x] = y;
}
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) pa[i] = i;
    for(int i = 1; i <= n; i++) {
        cin >> w;
        g.push_back({0, i, w});
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            cin >> p;
            if(i < j && p != 0) g.push_back({i, j, p});
        }
    }
    int ans = 0, cnt = 0;
    sort(g.begin(), g.end());
    for(auto &a : g){
        int u = a.u, v = a.v, w = a.w;
        //cerr << u << ' ' << v << ' ' << w << endl;
        if(find(u) != find(v)) {
            union_(u, v);
            ans += w;
            //cerr << ans << " ";
            cnt++;
        }
        if(cnt == n) break;
    }
    if(cnt == n) cout << ans << endl;
    else cout << inf << endl;
    return 0;
}
```

反思与总结，对于这类题目我们可以维护一个虚点，将虚点与各个点之间连边建图，跑最小生成树即可。
