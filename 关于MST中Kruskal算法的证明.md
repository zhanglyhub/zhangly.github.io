# **关于MST中Kruskal算法的证明**

在最小生成树中，我们最常用的算法是K算法，它写法简单，用到了贪心的思想和并查集的结构，下面就由本蒟蒻来说一下；  

不知道什么是最小生成树？  
一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。  
------来自百度百科  

说人话就是，给你一张图，你需要删掉一些边，使剩下的边中权值和最小，不能生成环。  
注意：最小生成树只出现在无向带权图中  

那么们如何来维护这个最小值呢？  
K算法的基本思想是维护一个森林，查询两颗树是否在一个集合中，如果在，合并；  

说人话：首先贪心对所有边的权值进行排序从小到大，然后初始每个节点为一颗树（也就是一个集合），从最小的边查起，查看联通的集合，合并，最后当合并完所有的集合，并且不存在环时，所生成的就是最小生成树。  

这时，聪明的你就要问了，如果存在多条权值相同的边，该怎么办呢？  
无所谓 一张图的MST又不是唯一的。  

-------------------------------------  

由于本蒟蒻不会Letex将就看吧

### *下面提供K算法的证明：   *

 首先，很容易得到我们的贪心的策略是正确的：   由数学归纳法：   当$k==1$时，我们去得全最小值，最优解，设为$a1$；   以后对于任意$k==n$，的最小值为$an$；   容易得出，在$k==n＋1$是有最小值$an＋1$   我没有累加所有的最小值，易得全局最小值  

其次，  
假设$T∈MST$，$F$为被$K$算法选中的边集合，我们只需要证明$ ∀，e∈F，$都被$MST$中的某棵所包含。

1）当F=∅时，所有MST包含所有空集成立。  
2）当e∈T时，F∪{e} ∈T，成立.  
3）当$e∉T，e∈F$时，则$T$必然中存在环$C$，而$f∪e ∈T$，而在$K$算法中是不能生成环的，根据环$C$的性质，**至少存在一条边**$f$，使得，$f∈T，f∉F $ 

为什么至少有一条？  
下面，我们来考虑一下权值关系  

1. $w(f) > =w(e)$  
   考虑反证法，假设$w(f) < w(e)$，$f$必然会被$k$算法先选择，导致$f∈ F$，这与之前的结论相矛盾，所以 w(f)>= w(e)。  

2. $w(f) <= w(e) $ 
   反证法，假设$w(f) > w(e)  $
   构造一颗$MST，T '= T ＋ e - f；  $
   $w(T') = w(T) ＋w(e) - w(f)  $
   所以：$w(T') > w(T)  $
   显然不成立  
   所以$w(f) <= w(e)  $
   综上所述：$ w(f) = w(e)  $
   假设在$fi，{f1，f2......fn}，$  
   因为$w(fi) = w(e）$  
   所以$w(T') = w(T)  $
   对于$fi$只要$w(fi) = w(e)，我们都能构造出T' = T$;
   
   

叽里咕噜说啥呢，好直接上代码：

# ***ACcode***



```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5005;
const int M = 2e6 + 5;
int n, m, pa[N], cc, ans;
struct node {
    int u, v, w;
    bool operator<(const node& x) const {
        return w < x.w;
    }
}a[M];
int find(int x) {return x == pa[x] ? x : pa[x] = find(pa[x]);}
void union_(int x, int y) {
    x = find(x), y = find(y);
    if(x != y) {
        pa[x] = y;
        cc--;
    }
}
int main() {
    cin >> n >> m;
    memset(pa, 0, sizeof(pa));
    cc = n;
    for(int i = 1; i <= m; i++) {
        cin >> a[i].u >> a[i].v >> a[i].w;
    } 
    for(int i = 1; i <= n; i++) {
        pa[i] = i;
    }
    sort(a + 1,a + m + 1);
    // for(int i = 1; i <= m; i++) cout << a[i].w << ' ';
    for(int i = 1; i <= m; i++) {
        if(find(a[i].u) != find(a[i].v)) {
            union_(a[i].u, a[i].v);
            ans += a[i].w;
            //cout << a[i].w << ' ';
        }
    }
    //cout << cc << endl;
    if(cc == 1) cout << ans << endl;
    else cout << "orz" << endl;
    return 0;
}


```

看起来也挺简单........................................................................的吧....................

好吧其实就一个并查集，最后说一下复杂度：
我们用了一个$Nlog(N)$的排序，$O(N)$的并查集，所以说整体复杂度为$O(N + log(N)$其中$N$为边的个数
